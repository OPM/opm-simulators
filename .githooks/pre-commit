#!/usr/bin/env python3
"""
pre-commit: ensure exactly one trailing newline in staged C/C++/Python/shell/yaml/cmake/markdown files.

This hook ensures that all staged source code files end with a newline. I.e. it adds a newline
at the end of the file if it is missing, or it truncates more than one newline at the end of the
file to a single newline.

It can be run locally or from CI (see .github/workflows/trailing_newline_checker.yml).

Rationale:
----------
According to the POSIX standard, a "line" in a text file is defined as a sequence of
zero or more non-newline characters plus a terminating newline character. Therefore, a text file,
by definition, should end with a newline. Some reasons why we should stick to this standard:
- Merge noise: Changes at the end of files may cause unnecessary conflicts. This is especially
  annoying when the changes are not related to the end of the file.
- Messy diffs: Git marks it specially when one version has the newline and another doesn't.

Other tools that do the same:
-----------------------------
- We already have a .clang-format file in the root of the repository (with "InsertNewlineAtEOF: true").
  But this also do other C++ formatting and does not apply to Python and shell scripts.
- Editors like VSCode and Cursor have settings to automatically add a newline at the end of the file. But
  sometimes files are edited in the terminal or generated by scripts and the editor does not run.

Installation:
-------------
To install locally, run:
  - git config core.hooksPath .githooks
To disable locally, run:
  - git config --unset core.hooksPath
To disable for a single commit, run:
  - git commit --no-verify
"""

import os
import re
import subprocess
import sys
from pathlib import Path

# ANSI color codes
class Colors:
    GREEN = '\033[92m'
    YELLOW = '\033[93m'
    BLUE = '\033[94m'
    RED = '\033[91m'
    BOLD = '\033[1m'
    RESET = '\033[0m'

def supports_color():
    """Check if the terminal supports color output."""
    return (
        hasattr(sys.stdout, 'isatty') and
        sys.stdout.isatty() and
        os.environ.get('TERM') != 'dumb'
    )

def colorize(text, color):
    """Apply color to text if terminal supports it."""
    if supports_color():
        return f"{color}{text}{Colors.RESET}"
    return text

CPP_EXT_RE = re.compile(r"\.(?:c|cc|cpp|cxx|h|hh|hpp|hxx)$", re.IGNORECASE)
PYTHON_EXT_RE = re.compile(r"\.(?:py)$", re.IGNORECASE)
SHELL_EXT_RE = re.compile(r"\.(?:sh)$", re.IGNORECASE)
YAML_EXT_RE = re.compile(r"\.(?:yml|yaml)$", re.IGNORECASE)
CMAKE_EXT_RE = re.compile(r"\.(?:cmake)$", re.IGNORECASE)
MARKDOWN_EXT_RE = re.compile(r"\.(?:md|markdown)$", re.IGNORECASE)

def run(*args, check=True, text=True, capture_output=True):
    return subprocess.run(args, check=check, text=text, capture_output=capture_output)

def is_probably_binary(path: Path, sample=4096) -> bool:
    try:
        with path.open("rb") as f:
            chunk = f.read(sample)
        # Heuristic: NUL byte -> likely binary
        return b"\x00" in chunk
    except FileNotFoundError:
        return True

def has_shebang(path: Path) -> bool:
    """Check if file starts with a shebang (executable script)."""
    try:
        with path.open("rb") as f:
            first_line = f.readline()
        return first_line.startswith(b"#!")
    except (FileNotFoundError, OSError):
        return False

def is_source_or_script_file(path: Path) -> bool:
    """Check if file is source code or executable script that should have normalized newlines."""
    # Check for known extensions first
    if (CPP_EXT_RE.search(path.name) or
        PYTHON_EXT_RE.search(path.name) or
        SHELL_EXT_RE.search(path.name) or
        YAML_EXT_RE.search(path.name) or
        CMAKE_EXT_RE.search(path.name) or
        MARKDOWN_EXT_RE.search(path.name)):
        return True

    # Check for CMakeLists.txt files specifically
    if path.name == "CMakeLists.txt":
        return True

    # Check for shebang (executable scripts without extension)
    return has_shebang(path)

def staged_paths():
    # Get names of staged, added/copied/modified files
    out = run("git", "diff", "--cached", "--name-only", "--diff-filter=ACM").stdout
    return [Path(p) for p in out.splitlines() if p.strip()]

def changed_paths():
    """Get names of files changed in the current commit/PR (for CI mode)."""
    # Check if we're in CI (GitHub Actions sets this)
    if os.environ.get('CI') == 'true':
        # In CI, check files changed in the current commit/PR
        # For PRs, compare with the base branch
        # For pushes, check the current commit
        try:
            # Try to get the base branch for PRs
            base = os.environ.get('GITHUB_BASE_REF')
            if base:
                # PR mode: compare with base branch
                out = run("git", "diff", "--name-only", "--diff-filter=ACM", f"origin/{base}...HEAD").stdout
            else:
                # Push mode: check files in the current commit
                out = run("git", "diff", "--name-only", "--diff-filter=ACM", "HEAD~1...HEAD").stdout
        except subprocess.CalledProcessError:
            # Fallback: if diff fails, don't check any files
            out = ""
    else:
        # Local mode: check staged files
        out = run("git", "diff", "--cached", "--name-only", "--diff-filter=ACM").stdout

    return [Path(p) for p in out.splitlines() if p.strip()]

def normalize_trailing_newline(p: Path) -> tuple[bool, int]:
    """
    Returns (was_changed, newline_delta) where:
    - was_changed: True if file was modified
    - newline_delta: number of newlines added (positive) or removed (negative)
    """
    try:
        data = p.read_bytes()
    except FileNotFoundError:
        return False, 0

    # Count trailing newlines
    trailing_newlines = 0
    for i in range(len(data) - 1, -1, -1):
        if data[i] in b"\r\n":
            trailing_newlines += 1
        else:
            break

    # Normalize to exactly one newline
    normalized = data.rstrip(b"\r\n") + b"\n"
    if normalized != data:
        p.write_bytes(normalized)
        # Calculate delta: we want 1 newline, so delta = 1 - original_count
        delta = 1 - trailing_newlines
        return True, delta
    return False, 0

def main():
    root = Path(run("git", "rev-parse", "--show-toplevel").stdout.strip())
    os.chdir(root)

    changed = []
    for p in changed_paths():
        # Only regular files in the worktree
        if not p.is_file():
            continue
        # Only C/C++/Python/shell files or executable scripts
        if not is_source_or_script_file(p):
            continue
        # Skip likely binaries (e.g., accidentally staged artifacts)
        if is_probably_binary(p):
            continue

        was_changed, delta = normalize_trailing_newline(p)
        if was_changed:
            # Re-stage so the commit contains the fix (only in local mode)
            if os.environ.get('CI') != 'true':
                run("git", "add", "--", str(p))
            changed.append((str(p), delta))

    if changed:
        header = colorize(f"pre-commit: normalized trailing newline in {len(changed)} file(s):", Colors.BOLD + Colors.GREEN)
        print(header)
        for filename, delta in changed:
            bullet = colorize("  â€¢", Colors.BLUE)
            filename_colored = colorize(filename, Colors.YELLOW)
            if delta > 0:
                delta_text = colorize(f"(+{delta})", Colors.RED)
            elif delta < 0:
                delta_text = colorize(f"({delta})", Colors.RED)
            else:
                delta_text = colorize("(0)", Colors.BLUE)
            print(f"{bullet} {filename_colored} {delta_text}")

    # Return different exit codes based on environment
    if os.environ.get('CI') == 'true' and changed:
        # In CI: fail if files were changed (workflow should fail)
        print(colorize("\nCI mode: failing workflow because files needed trailing newline fixes.", Colors.BOLD + Colors.RED))
        return 1
    else:
        # Local mode: always succeed (commit can proceed)
        return 0

if __name__ == "__main__":
    try:
        sys.exit(main())
    except subprocess.CalledProcessError as e:
        # Fail closed if a git command errors unexpectedly
        error_msg = colorize(f"[pre-commit] Error: {e}", Colors.BOLD + Colors.YELLOW)
        print(error_msg, file=sys.stderr)
        sys.exit(1)
