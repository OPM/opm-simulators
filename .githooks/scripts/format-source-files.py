#!/usr/bin/env python3
"""
format-source-files.py: fix trailing newlines and whitespace in staged C/C++/Python/shell/yaml/cmake/markdown files.

This script performs two formatting fixes on staged source code files:
1. Ensures exactly one trailing newline at end of file
2. Removes trailing whitespace from lines (except in Markdown files where trailing spaces create line breaks)

For all file types:
- Adds a newline at the end if missing, or truncates multiple newlines to exactly one

For non-Markdown files only:
- Removes trailing whitespace from all lines
- Preserves Markdown trailing space line breaks (two+ spaces at end of line create <br>)

It can be run locally or from CI (see .github/workflows/trailing_newline_checker.yml).

Rationale:
----------
Trailing newlines: According to the POSIX standard, a "line" is defined as a sequence of
zero or more non-newline characters plus a terminating newline. Therefore text files
should end with a newline to avoid merge noise and messy diffs.

Trailing whitespace: Trailing whitespace is generally unwanted as it:
- Creates visual noise in editors that show whitespace
- Can cause unnecessary diff noise when different editors handle it differently
- Is often accidentally introduced and serves no purpose (except Markdown line breaks)

Other tools that do the same:
-----------------------------
- We already have a .clang-format file in the root of the repository (with "InsertNewlineAtEOF: true").
  But this also do other C++ formatting and does not apply to Python and shell scripts.
- Editors like VSCode and Cursor have settings to automatically fix these issues. But
  sometimes files are edited in the terminal or generated by scripts where editors don't run.

Installation:
-------------
To install locally, run:
  - git config core.hooksPath .githooks
To disable locally, run:
  - git config --unset core.hooksPath
To disable for a single commit, run:
  - git commit --no-verify
"""

import os
import re
import subprocess
import sys
from pathlib import Path

# ANSI color codes
class Colors:
    GREEN = '\033[92m'
    YELLOW = '\033[93m'
    BLUE = '\033[94m'
    RED = '\033[91m'
    BOLD = '\033[1m'
    RESET = '\033[0m'

def supports_color():
    """Check if the terminal supports color output."""
    return (
        hasattr(sys.stdout, 'isatty') and
        sys.stdout.isatty() and
        os.environ.get('TERM') != 'dumb'
    )

def colorize(text, color):
    """Apply color to text if terminal supports it."""
    if supports_color():
        return f"{color}{text}{Colors.RESET}"
    return text

CPP_EXT_RE = re.compile(r"\.(?:c|cc|cpp|cxx|h|hh|hpp|hxx)$", re.IGNORECASE)
PYTHON_EXT_RE = re.compile(r"\.(?:py)$", re.IGNORECASE)
SHELL_EXT_RE = re.compile(r"\.(?:sh)$", re.IGNORECASE)
YAML_EXT_RE = re.compile(r"\.(?:yml|yaml)$", re.IGNORECASE)
CMAKE_EXT_RE = re.compile(r"\.(?:cmake)$", re.IGNORECASE)
MARKDOWN_EXT_RE = re.compile(r"\.(?:md|markdown)$", re.IGNORECASE)

def run(*args, check=True, text=True, capture_output=True):
    return subprocess.run(args, check=check, text=text, capture_output=capture_output)

def is_probably_binary(path: Path, sample=4096) -> bool:
    try:
        with path.open("rb") as f:
            chunk = f.read(sample)
        # Heuristic: NUL byte -> likely binary
        return b"\x00" in chunk
    except FileNotFoundError:
        return True

def has_shebang(path: Path) -> bool:
    """Check if file starts with a shebang (executable script)."""
    try:
        with path.open("rb") as f:
            first_line = f.readline()
        return first_line.startswith(b"#!")
    except (FileNotFoundError, OSError):
        return False

def is_markdown_file(path: Path) -> bool:
    """Check if file is a Markdown file where trailing spaces are significant."""
    return bool(MARKDOWN_EXT_RE.search(path.name))

def is_source_or_script_file(path: Path) -> bool:
    """Check if file is source code or executable script that should have normalized newlines."""
    # Check for known extensions first
    if (CPP_EXT_RE.search(path.name) or
        PYTHON_EXT_RE.search(path.name) or
        SHELL_EXT_RE.search(path.name) or
        YAML_EXT_RE.search(path.name) or
        CMAKE_EXT_RE.search(path.name) or
        MARKDOWN_EXT_RE.search(path.name)):
        return True

    # Check for CMakeLists.txt files specifically
    if path.name == "CMakeLists.txt":
        return True

    # Check for shebang (executable scripts without extension)
    return has_shebang(path)

def staged_paths():
    # Get names of staged, added/copied/modified files
    out = run("git", "diff", "--cached", "--name-only", "--diff-filter=ACM").stdout
    return [Path(p) for p in out.splitlines() if p.strip()]

def changed_paths():
    """Get names of files changed in the current commit/PR (for CI mode)."""
    # Check if we're in CI (GitHub Actions sets this)
    if os.environ.get('CI') == 'true':
        # In CI, check files changed in the current commit/PR
        # For PRs, compare with the base branch
        # For pushes, check the current commit
        try:
            # Try to get the base branch for PRs
            base = os.environ.get('GITHUB_BASE_REF')
            if base:
                # PR mode: compare with base branch
                out = run("git", "diff", "--name-only", "--diff-filter=ACM", f"origin/{base}...HEAD").stdout
            else:
                # Push mode: check files in the current commit
                out = run("git", "diff", "--name-only", "--diff-filter=ACM", "HEAD~1...HEAD").stdout
        except subprocess.CalledProcessError:
            # Fallback: if diff fails, don't check any files
            out = ""
    else:
        # Local mode: check staged files
        out = run("git", "diff", "--cached", "--name-only", "--diff-filter=ACM").stdout

    return [Path(p) for p in out.splitlines() if p.strip()]

def normalize_trailing_newline(p: Path) -> tuple[bool, int]:
    """
    Returns (was_changed, newline_delta) where:
    - was_changed: True if file was modified
    - newline_delta: number of newlines added (positive) or removed (negative)
    """
    try:
        data = p.read_bytes()
    except FileNotFoundError:
        return False, 0

    # Count trailing newlines
    trailing_newlines = 0
    for i in range(len(data) - 1, -1, -1):
        if data[i] in b"\r\n":
            trailing_newlines += 1
        else:
            break

    # Normalize to exactly one newline
    normalized = data.rstrip(b"\r\n") + b"\n"
    if normalized != data:
        p.write_bytes(normalized)
        # Calculate delta: we want 1 newline, so delta = 1 - original_count
        delta = 1 - trailing_newlines
        return True, delta
    return False, 0

def trim_trailing_whitespace(p: Path) -> tuple[bool, int]:
    """
    Remove trailing whitespace from all lines in the file.

    Returns (was_changed, lines_affected) where:
    - was_changed: True if file was modified
    - lines_affected: number of lines that had trailing whitespace removed
    """
    try:
        data = p.read_text(encoding='utf-8', errors='ignore')
    except FileNotFoundError:
        return False, 0

    lines = data.splitlines(keepends=True)
    modified_lines = 0
    changed = False

    for i, line in enumerate(lines):
        # Remove trailing whitespace but preserve line endings
        if line.endswith(('\r\n', '\n')):
            # Line has line ending
            line_ending = '\r\n' if line.endswith('\r\n') else '\n'
            content = line[:-len(line_ending)]
            stripped_content = content.rstrip()
            if content != stripped_content:
                lines[i] = stripped_content + line_ending
                modified_lines += 1
                changed = True
        else:
            # Line has no line ending (likely last line)
            stripped_content = line.rstrip()
            if line != stripped_content:
                lines[i] = stripped_content
                modified_lines += 1
                changed = True

    if changed:
        p.write_text(''.join(lines), encoding='utf-8')

    return changed, modified_lines

def main():
    root = Path(run("git", "rev-parse", "--show-toplevel").stdout.strip())
    os.chdir(root)

    changed = []
    for p in changed_paths():
        # Only regular files in the worktree
        if not p.is_file():
            continue
        # Only C/C++/Python/shell files or executable scripts
        if not is_source_or_script_file(p):
            continue
        # Skip likely binaries (e.g., accidentally staged artifacts)
        if is_probably_binary(p):
            continue

        # Always normalize trailing newlines
        newline_changed, newline_delta = normalize_trailing_newline(p)

        # Trim trailing whitespace for non-Markdown files only
        whitespace_changed, whitespace_lines = False, 0
        if not is_markdown_file(p):
            whitespace_changed, whitespace_lines = trim_trailing_whitespace(p)

        # Track changes
        if newline_changed or whitespace_changed:
            # Re-stage so the commit contains the fix (only in local mode)
            if os.environ.get('CI') != 'true':
                run("git", "add", "--", str(p))
            changed.append((str(p), newline_delta, whitespace_lines))

    if changed:
        header = colorize(f"format-source-files: fixed formatting in {len(changed)} file(s):", Colors.BOLD + Colors.GREEN)
        print(header)
        for filename, newline_delta, whitespace_lines in changed:
            bullet = colorize("  â€¢", Colors.BLUE)
            filename_colored = colorize(filename, Colors.YELLOW)

            # Build status text
            status_parts = []
            if newline_delta != 0:
                if newline_delta > 0:
                    status_parts.append(colorize(f"newlines: +{newline_delta}", Colors.RED))
                else:
                    status_parts.append(colorize(f"newlines: {newline_delta}", Colors.RED))

            if whitespace_lines > 0:
                status_parts.append(colorize(f"whitespace: {whitespace_lines} lines", Colors.RED))

            if not status_parts:
                status_text = colorize("(no changes)", Colors.BLUE)
            else:
                status_text = f"({', '.join(status_parts)})"

            print(f"{bullet} {filename_colored} {status_text}")

    # Return different exit codes based on environment
    if os.environ.get('CI') == 'true' and changed:
        # In CI: fail if files were changed (workflow should fail)
        print(colorize("\nCI mode: failing workflow because files needed trailing newline fixes.",
            Colors.BOLD + Colors.RED))
        return 1
    else:
        # Local mode: always succeed (commit can proceed)
        return 0

if __name__ == "__main__":
    try:
        sys.exit(main())
    except subprocess.CalledProcessError as e:
        # Fail closed if a git command errors unexpectedly
        error_msg = colorize(f"[format-source-files] Error: {e}", Colors.BOLD + Colors.YELLOW)
        print(error_msg, file=sys.stderr)
        sys.exit(1)
